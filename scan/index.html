<!--
Fixed: robust freeze/unfreeze lifecycle, single-offscreen canvas for freeze, safe ImageBitmap path,
and real-time text→QR rendering (small QR overlay). Paste and run on modern mobile WebKit.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
<title>Lifetime Freight Scanner — Fixed + Live QR</title>

<!-- Tesseract v5 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<!-- QR generator (qrcodejs) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<style>
html,body{margin:0;padding:0;height:100%;background:#000;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;touch-action:none;-webkit-user-select:none}
#canvas{position:absolute;top:0;left:0;width:120vw;height:120vh;object-fit:cover;transform-origin:center center;will-change:transform;pointer-events:none}
#statusOverlay{position:absolute;top:0;left:0;width:100%;background:rgba(0,100,255,.9);color:#fff;padding:.75rem;text-align:center;display:none;z-index:30;user-select:none;font-weight:bold}
#ticketInputArea{position:absolute;left:50%;bottom:calc(35vh + 20px);transform:translateX(-50%);min-width:60%;max-width:90%;background:rgba(0,0,0,.7);color:#fff;padding:.45rem .9rem;font-size:1.1rem;border:none;border-radius:.28rem;overflow:hidden;line-height:1.2em;white-space:nowrap;z-index:21;cursor:text;overflow-x:auto;text-align:center}
#ticketInputArea:empty::before{content:attr(data-placeholder);color:#888}
#keyboard{position:absolute;bottom:0;width:100%;height:35vh;background:#111;box-sizing:border-box;display:flex;flex-direction:column;transition:height .2s;z-index:19;user-select:none}
#keyboard-resizer{height:16px;background:#333;border-top-left-radius:8px;border-top-right-radius:8px;display:flex;justify-content:center;align-items:center;touch-action:none;z-index:20}
#notch{width:40px;height:4px;background:#666;border-radius:2px}
.key-row{flex:1;display:flex;justify-content:space-between;gap:2px;margin:.1rem .2rem}
button.key{flex:1;min-width:30px;max-width:60px;background:#222;color:#fff;border:none;border-radius:.3rem;font-size:1.05rem;touch-action:none;transition:transform .08s,background .08s}
button.key:active,button.key.active{background:#444;transform:scale(1.04)}
button.key.clear{flex:0 0 20%;min-width:80px;max-width:120px;background:#800}
button.key.action{background:#046;font-size:1rem;font-weight:bold}
#freightSubmission{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:80%;max-width:420px;background:rgba(255,255,255,0.95);padding:18px;border-radius:8px;box-shadow:0 0 20px rgba(0,0,0,.5);z-index:40;text-align:center;color:#111}
.hidden{display:none!important}

/* QR overlay */
#qrOverlay{position:absolute;right:12px;bottom:calc(35vh + 20px);width:112px;height:112px;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;z-index:22;box-shadow:0 6px 20px rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center}
#qrOverlay canvas{width:100%;height:100%;object-fit:contain}
</style>
</head>
<body>
<canvas id="canvas" aria-hidden="true"></canvas>
<div id="statusOverlay" role="status" aria-live="polite"></div>

<div id="ticketInputArea" data-placeholder="Scan Ticket ID or Tap to Type" aria-label="Ticket input area" contenteditable="false" spellcheck="false"></div>

<div id="freightSubmission" class="hidden" role="dialog" aria-modal="true" aria-labelledby="submissionTitle">
    <h2 id="submissionTitle">Shipment Ticket Submission</h2>
    <p>Ticket ID: <strong id="submittedTicketID"></strong></p>
    <div id="submissionResult" role="status" aria-live="polite"></div>
    <button id="submitBtn" type="button">Submit to Lifetime Freight</button>
    <button id="clearBtn" type="button" style="background:#555">Clear & Continue Scanning</button>
</div>

<div id="keyboard" aria-hidden="false">
  <div id="keyboard-resizer"><div id="notch" aria-hidden="true"></div></div>
</div>

<!-- QR overlay -->
<div id="qrOverlay" aria-hidden="false" title="Live QR of ticket">
  <div id="qrHolder"></div>
</div>

<script>
/* eslint-disable no-console */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const statusOv = document.getElementById('statusOverlay');
const ticketInputArea = document.getElementById('ticketInputArea');
const keyboard = document.getElementById('keyboard');
const resizer = document.getElementById('keyboard-resizer');
const freightSubmission = document.getElementById('freightSubmission');
const submitBtn = document.getElementById('submitBtn');
const clearBtn = document.getElementById('clearBtn');
const submittedTicketID = document.getElementById('submittedTicketID');
const submissionResult = document.getElementById('submissionResult');
const qrHolder = document.getElementById('qrHolder');
const qrOverlay = document.getElementById('qrOverlay');

let videoEl = null;
let animFrame = null;
let posX = 0, posY = 0;
let freeze = false;
let freezeBitmap = null;          // ImageBitmap for efficient frozen frame
let freezeCanvas = null;          // one-off canvas for barcode/ocr scans
let barcodeDetector = null;
let tesseractWorker = null;
let tesseractReady = false;
let qrInstance = null;
let qrDebounceTimer = null;

// --- helpers ---
function displayStatus(msg, duration = 0, isError = false) {
  statusOv.textContent = msg;
  statusOv.style.background = isError ? 'rgba(255,0,0,.9)' : 'rgba(0,100,255,.9)';
  statusOv.style.display = 'block';
  if (duration > 0) setTimeout(() => { statusOv.style.display = 'none'; }, duration);
}

function setCanvasSize(w, h) {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  canvas.style.width = `${w}px`;
  canvas.style.height = `${h}px`;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// --- freeze lifecycle (single offscreen bitmap) ---
async function ensureFrozen() {
  if (freeze || !videoEl || videoEl.readyState < 2) return;
  freeze = true;
  try {
    // reuse offscreen freezeCanvas for conversion if needed
    if (!freezeCanvas) freezeCanvas = document.createElement('canvas');
    freezeCanvas.width = videoEl.videoWidth || 640;
    freezeCanvas.height = videoEl.videoHeight || 360;
    const fctx = freezeCanvas.getContext('2d', { willReadFrequently: true });
    fctx.drawImage(videoEl, 0, 0, freezeCanvas.width, freezeCanvas.height);

    // create ImageBitmap where supported (fast to draw)
    if ('createImageBitmap' in window) {
      if (freezeBitmap) freezeBitmap.close && freezeBitmap.close();
      freezeBitmap = await createImageBitmap(freezeCanvas);
    } else {
      // fallback: keep canvas as source
      freezeBitmap = freezeCanvas;
    }
    displayStatus('View frozen', 600);
  } catch (err) {
    console.error('freeze failed', err);
    freeze = false;
    freezeBitmap = null;
    displayStatus('Freeze failed', 1200, true);
  }
}

function unfreezeView() {
  freeze = false;
  if (freezeBitmap && freezeBitmap.close) try { freezeBitmap.close(); } catch(e) {}
  freezeBitmap = null;
  displayStatus('Scanner active', 600);
}

// --- ticket handling ---
function handleTicketScan(rawText) {
  if (!rawText) return;
  const cleanedText = String(rawText).trim().toUpperCase().replace(/\s+/g, '');
  if (cleanedText.length >= 6) {
    ticketInputArea.textContent = cleanedText;
    updateQRImmediate(cleanedText);
    showSubmissionUI(cleanedText);
  } else {
    // append and keep scanning
    ticketInputArea.textContent = (ticketInputArea.textContent + ' ' + rawText).trim();
    updateQRDebounced();
  }
  ticketInputArea.scrollLeft = ticketInputArea.scrollWidth;
}

function showSubmissionUI(ticketID) {
  ensureFrozen();
  submittedTicketID.textContent = ticketID;
  submissionResult.innerHTML = '';
  freightSubmission.classList.remove('hidden');
  submitBtn.focus();
}

function clearTicketID() {
  ticketInputArea.textContent = '';
  freightSubmission.classList.add('hidden');
  updateQRImmediate('');
  unfreezeView();
}

// --- submission handlers (placeholder) ---
submitBtn.addEventListener('click', () => {
  const ticketID = submittedTicketID.textContent;
  submissionResult.innerHTML = `<p style="color:#0078ff;">✅ Submitting Ticket ${ticketID}…</p>`;
  setTimeout(() => {
    submissionResult.innerHTML = `<p style="color:#1e8449;font-weight:bold;">Locker Ready — Ticket processed.</p>`;
  }, 900);
});
clearBtn.addEventListener('click', clearTicketID);

// --- camera + scanners ---
async function startCamera() {
  try {
    const constraints = { video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl = document.createElement('video');
    videoEl.srcObject = stream;
    videoEl.playsInline = true;
    videoEl.muted = true;
    await videoEl.play();

    // canvas sizing: use CSS target size for transform to avoid blurring
    const wantedW = Math.round(videoEl.videoWidth * 1.2);
    const wantedH = Math.round(videoEl.videoHeight * 1.2);
    setCanvasSize(wantedW, wantedH);
    displayStatus('Camera started', 600);
    if (!animFrame) animFrame = requestAnimationFrame(draw);
  } catch (err) {
    displayStatus('Camera unavailable: ' + (err && err.message ? err.message : err), 0, true);
    console.error(err);
  }
}

async function initializeScanners() {
  // BarcodeDetector (best-effort)
  if ('BarcodeDetector' in window) {
    try {
      barcodeDetector = new BarcodeDetector({ formats: ['qr_code', 'ean_13', 'upc_a', 'code_128'] });
    } catch (e) {
      console.warn('BarcodeDetector init failed', e);
      barcodeDetector = null;
    }
  }

  // Tesseract worker lifecycle
  try {
    displayStatus('Initializing OCR...', 0);
    if (!tesseractWorker) {
      tesseractWorker = Tesseract.createWorker({ logger: m => { /* silent */ } });
      await tesseractWorker.load();
      await tesseractWorker.loadLanguage('eng');
      await tesseractWorker.initialize('eng');
      // reduce recognition variable noise
      await tesseractWorker.setParameters({ tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789- ' });
    }
    tesseractReady = true;
    displayStatus('OCR ready', 700);
  } catch (e) {
    tesseractReady = false;
    console.error('Tesseract init failed', e);
    displayStatus('OCR failed to initialize', 2500, true);
  }
}

// --- OCR/Barcode flow (use freezeBitmap when available) ---
function sourceForScan() {
  // prefer freezeBitmap for scanning (stable)
  if (freeze && freezeBitmap) return freezeBitmap;
  if (videoEl && videoEl.readyState >= 2) return videoEl;
  return null;
}

async function runBarcodeScan() {
  if (!barcodeDetector) {
    displayStatus('Barcode detector unavailable. Use Scan Text', 1600, true);
    return;
  }
  displayStatus('Scanning barcode...', 0);
  try {
    // feed either ImageBitmap or video into a temporary canvas for BarcodeDetector
    const src = sourceForScan();
    if (!src) { displayStatus('No image available', 1200, true); return; }

    // ensure we have a canvas matching source dimensions
    const c = document.createElement('canvas');
    c.width = src.width || src.videoWidth || 640;
    c.height = src.height || src.videoHeight || 360;
    const cctx = c.getContext('2d');
    if (src instanceof ImageBitmap || src instanceof HTMLCanvasElement) cctx.drawImage(src, 0, 0, c.width, c.height);
    else cctx.drawImage(src, 0, 0, c.width, c.height);

    const codes = await barcodeDetector.detect(c);
    if (codes && codes.length) {
      handleTicketScan(codes[0].rawValue || codes[0].rawText || codes[0].displayValue || '');
      displayStatus('Barcode: ' + (codes[0].format || 'unknown'), 1400);
    } else {
      displayStatus('No barcode detected', 1200);
    }
  } catch (e) {
    console.error('Barcode scan failed', e);
    displayStatus('Barcode scan failed', 1600, true);
  }
}

async function runOCR() {
  if (!tesseractReady || !tesseractWorker) { displayStatus('OCR not ready', 1600, true); return; }
  displayStatus('Recognizing text...', 0);
  try {
    const src = sourceForScan();
    if (!src) { displayStatus('No image to OCR', 1600, true); return; }

    // produce a compact preprocessed canvas (use freezeBitmap or video)
    const pre = preprocessForOCR(src);
    const { data: { text } } = await tesseractWorker.recognize(pre);
    handleTicketScan(text || '');
    displayStatus('Text recognized', 1000);
  } catch (e) {
    console.error('OCR failed', e);
    displayStatus('OCR failed', 1600, true);
  }
}

// --- preprocessing (accept ImageBitmap or Video or Canvas) ---
function preprocessForOCR(src) {
  // create working canvas sized to maintain legibility without huge cost
  const w = (src.width || src.videoWidth || 640);
  const h = (src.height || src.videoHeight || 360);
  const maxDim = 1024;
  const scale = Math.min(1, maxDim / Math.max(w, h));
  const out = document.createElement('canvas');
  out.width = Math.max(240, Math.round(w * scale));
  out.height = Math.max(80, Math.round(h * scale));
  const octx = out.getContext('2d');
  // draw and then apply high-contrast thresholding
  if (src instanceof ImageBitmap || src instanceof HTMLCanvasElement) octx.drawImage(src, 0, 0, out.width, out.height);
  else octx.drawImage(src, 0, 0, out.width, out.height);

  const img = octx.getImageData(0, 0, out.width, out.height);
  const d = img.data;
  for (let i = 0; i < d.length; i += 4) {
    const r = d[i], g = d[i + 1], b = d[i + 2];
    const l = 0.299 * r + 0.587 * g + 0.114 * b;
    const bw = l > 140 ? 255 : 0;
    d[i] = d[i + 1] = d[i + 2] = bw;
  }
  octx.putImageData(img, 0, 0);
  return out;
}

// --- video->canvas helper (kept lightweight) ---
function videoToCanvas(vid) {
  const c = document.createElement('canvas');
  c.width = vid.videoWidth || 640;
  c.height = vid.videoHeight || 360;
  c.getContext('2d').drawImage(vid, 0, 0, c.width, c.height);
  return c;
}

// --- stabilization math (unchanged) ---
let quat = [1, 0, 0, 0];
function eulerToQuat(yaw, pitch, roll) {
  const cy = Math.cos(yaw * 0.5), sy = Math.sin(yaw * 0.5);
  const cp = Math.cos(pitch * 0.5), sp = Math.sin(pitch * 0.5);
  const cr = Math.cos(roll * 0.5), sr = Math.sin(roll * 0.5);
  return [cr * cp * cy + sr * sp * sy, sr * cp * cy - cr * sp * sy, cr * sp * cy + sr * cp * sy, cr * cp * sy - sr * sp * cy];
}
function quatToMatrix(q) {
  const [w, x, y, z] = q;
  const a = 1 - 2 * y * y - 2 * z * z;
  const b = 2 * x * y - 2 * z * w;
  const c = 2 * x * y + 2 * z * w;
  const d = 1 - 2 * x * x - 2 * z * z;
  return [a, b, c, d];
}

// --- device sensors ---
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', (e) => {
    if (e.alpha === null) return;
    quat = eulerToQuat((e.alpha || 0) * Math.PI / 180, (e.beta || 0) * Math.PI / 180, (e.gamma || 0) * Math.PI / 180);
  }, { passive: true });
}
if (window.DeviceMotionEvent) {
  (function () {
    let ex = 0, ey = 0;
    const damping = 0.95;
    window.addEventListener('devicemotion', (e) => {
      const acc = e.accelerationIncludingGravity;
      if (!acc) return;
      ex = (ex + (acc.x || 0) * 0.02) * damping;
      ey = (ey + (acc.y || 0) * 0.02) * damping;
      posX += 0.01 * ex;
      posY += 0.01 * ey;
      const maxOffset = (canvas.width / (window.devicePixelRatio || 1)) * 0.1;
      posX = Math.max(-maxOffset, Math.min(maxOffset, posX));
      posY = Math.max(-maxOffset, Math.min(maxOffset, posY));
    }, { passive: true });
  }());
}

// --- draw loop ---
function draw() {
  if (!canvas) return;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();

  const cssW = canvas.width / (window.devicePixelRatio || 1);
  const cssH = canvas.height / (window.devicePixelRatio || 1);
  ctx.translate(cssW / 2 + posX, cssH / 2 + posY);
  const m = quatToMatrix(quat);
  ctx.transform(m[0], m[1], m[2], m[3], 0, 0);

  const source = freeze && freezeBitmap ? freezeBitmap : videoEl;
  if (source && (source.readyState >= 2 || freezeBitmap)) {
    try {
      ctx.drawImage(source, -cssW / 2, -cssH / 2, cssW, cssH);
    } catch (e) {
      if (videoEl && videoEl.readyState >= 2) ctx.drawImage(videoEl, -cssW / 2, -cssH / 2, cssW, cssH);
    }
  } else {
    ctx.fillStyle = '#111';
    ctx.fillRect(-cssW / 2, -cssH / 2, cssW, cssH);
  }

  ctx.restore();
  animFrame = requestAnimationFrame(draw);
}

// --- keyboard resizing (unchanged) ---
let isResizing = false, sy = 0, sh = 0;
function onTouchMove(e) {
  if (!isResizing) return;
  e.preventDefault();
  const t = sy - e.touches[0].clientY;
  const h = Math.max(.15 * innerHeight, Math.min(.8 * innerHeight, sh + t));
  requestAnimationFrame(() => {
    keyboard.style.height = h + 'px';
    ticketInputArea.style.bottom = `calc(${h}px + 20px)`;
  });
}
resizer.addEventListener('touchstart', (e) => {
  sy = e.touches[0].clientY; sh = keyboard.offsetHeight; isResizing = true;
  window.addEventListener('touchmove', onTouchMove, { passive: false });
});
const endResize = () => { isResizing = false; window.removeEventListener('touchmove', onTouchMove); };
window.addEventListener('touchend', endResize);
window.addEventListener('touchcancel', endResize);

// --- keyboard layout + handlers (unchanged) ---
const layout = [
  ['SCAN-TEXT', 'SCAN-CODE'],
  ['1','2','3','4','5','6','7','8','9','0'],
  ['Q','W','E','R','T','Y','U','I','O','P'],
  ['A','S','D','F','G','H','J','K','L'],
  ['Z','X','C','V','B','N','M','←','CLR']
];
layout.forEach(row => {
  const rowDiv = document.createElement('div'); rowDiv.className = 'key-row';
  row.forEach(k => {
    const btn = document.createElement('button'); btn.type = 'button';
    let cls = 'key'; if (k === 'CLR') cls += ' clear'; if (k.startsWith('SCAN')) cls += ' action';
    btn.className = cls;
    btn.textContent = (k === 'CLR') ? 'Clear' : (k === 'SCAN-TEXT') ? 'Scan Text' : (k === 'SCAN-CODE') ? 'Scan Code' : k;
    btn.addEventListener('touchstart', () => btn.classList.add('active'), { passive: true });
    btn.addEventListener('touchend', () => btn.classList.remove('active'), { passive: true });
    btn.addEventListener('click', async () => {
      switch (k) {
        case 'CLR': clearTicketID(); break;
        case '←': ticketInputArea.textContent = ticketInputArea.textContent.slice(0, -1); updateQRDebounced(); break;
        case 'SCAN-TEXT': await runOCR(); break;
        case 'SCAN-CODE': await runBarcodeScan(); break;
        default:
          ticketInputArea.textContent += k;
          updateQRDebounced();
          ensureFrozen();
      }
      ticketInputArea.scrollLeft = ticketInputArea.scrollWidth;
    });
    rowDiv.appendChild(btn);
  });
  keyboard.appendChild(rowDiv);
});

// --- ticket area tap toggles freeze and enables editing via long-tap (quick toggle freeze/unfreeze) ---
let touchStartTs = 0;
ticketInputArea.addEventListener('touchstart', (e) => { touchStartTs = Date.now(); }, { passive: true });
ticketInputArea.addEventListener('touchend', (e) => {
  const dt = Date.now() - touchStartTs;
  if (dt > 600) {
    // long press -> enable inline edit for manual typing (mobile keyboard)
    ticketInputArea.contentEditable = 'true';
    ticketInputArea.focus();
    // show native keyboard heuristics
  } else {
    // short tap toggles freeze state
    if (!freeze) ensureFrozen(); else unfreezeView();
  }
}, { passive: true });

// when user finishes manual edit, disable contentEditable and update QR
ticketInputArea.addEventListener('blur', () => {
  ticketInputArea.contentEditable = 'false';
  updateQRDebounced();
});

// observe content to unfreeze when cleared
const observer = new MutationObserver(() => {
  if (ticketInputArea.textContent.trim() === '') unfreezeView();
  updateQRDebounced();
});
observer.observe(ticketInputArea, { childList: true, subtree: true, characterData: true });

// --- QR generation (debounced + immediate) ---
function updateQRImmediate(text) {
  if (!text) {
    qrHolder.innerHTML = '';
    return;
  }
  qrHolder.innerHTML = '';
  // qrcodejs creates an element inside qrHolder
  try {
    new QRCode(qrHolder, {
      text: text,
      width: 96,
      height: 96,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRCode.CorrectLevel.M
    });
  } catch (e) {
    // fallback: tiny dataURI using canvas (rare)
    const c = document.createElement('canvas'); c.width = 96; c.height = 96;
    c.getContext('2d').fillStyle = '#fff'; c.getContext('2d').fillRect(0,0,96,96);
    qrHolder.appendChild(c);
  }
}

function updateQRDebounced() {
  clearTimeout(qrDebounceTimer);
  qrDebounceTimer = setTimeout(() => {
    updateQRImmediate(ticketInputArea.textContent.trim());
  }, 120); // tight debounce for live feel
}

// --- lifecycle / cleanup ---
async function shutdown() {
  if (animFrame) cancelAnimationFrame(animFrame);
  if (videoEl && videoEl.srcObject) {
    const tracks = videoEl.srcObject.getTracks();
    tracks.forEach(t => t.stop());
  }
  if (freezeBitmap && freezeBitmap.close) try { freezeBitmap.close(); } catch (e) {}
  freezeBitmap = null;
  if (tesseractWorker) {
    try { await tesseractWorker.terminate(); } catch (e) { /* ignore */ }
    tesseractWorker = null;
    tesseractReady = false;
  }
}
window.addEventListener('beforeunload', shutdown);
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    if (animFrame) cancelAnimationFrame(animFrame);
    if (videoEl && videoEl.srcObject) {
      const tracks = videoEl.srcObject.getVideoTracks();
      tracks.forEach(t => t.enabled = false);
    }
  } else {
    if (videoEl && videoEl.srcObject) {
      const tracks = videoEl.srcObject.getVideoTracks();
      tracks.forEach(t => t.enabled = true);
    }
    if (!animFrame) animFrame = requestAnimationFrame(draw);
  }
});

// --- init ---
(async function init() {
  // small defensive size
  setCanvasSize(window.innerWidth, window.innerHeight);
  await initializeScanners();
  await startCamera();
  // ensure QR overlay reflects initial content
  updateQRImmediate(ticketInputArea.textContent.trim());
})();
</script>
</body>
</html>